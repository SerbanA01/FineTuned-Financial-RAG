import re
from dateutil import parser as date_parser
from datetime import datetime

def remove_chunk_references(text: str) -> str:
    """
    Strips internal citation markers (e.g., "[CHUNK 1]") from the final text.

    This is a post-processing step to clean up the LLM's generated answer before
    presenting it to the user. While the citations are critical for internal
    reasoning and debugging, they are removed from the final output for a cleaner
    and more natural user experience.

    @param text: The text generated by the LLM, potentially containing chunk references.
    @return: A cleaned string with all citation markers removed.
    """
    # This regex is designed to find the literal "[CHUNK" followed by any characters
    # that are not a closing bracket (`[^\]]*`), and then the closing bracket `]`.
    # This robustly handles various citation formats like [CHUNK 1], [CHUNK 2-8], etc.
    cleaned_text = re.sub(r"\[CHUNK[^\]]*\]", "", text)
    return cleaned_text.strip()

def extract_date_from_query(query: str) -> str:
    """
    Extracts the first valid date found in a query string using robust parsing.

    This function is used to identify if the user is asking about a specific
    historical point in time, which is particularly useful for market data queries
    (e.g., "what was the price of MSFT on January 3, 2022?"). It tries multiple
    common date formats and uses the flexible `dateutil` library to parse the
    first valid match.

    @param query: The raw user query string.
    @return: The first date found, formatted as a "YYYY-MM-DD" string, or an
             empty string if no valid date is found.
    """
    # A list of regex patterns to identify common ways dates are written.
    # This pre-filtering helps guide the parser and avoid incorrect matches on random numbers.
    date_patterns = [
        r"\b\d{4}-\d{1,2}-\d{1,2}\b",  # YYYY-MM-DD or YYYY-M-D
        r"\b\d{4}/\d{1,2}/\d{1,2}\b",  # YYYY/MM/DD or YYYY/M/D
        r"\b\d{1,2}[-/]\d{1,2}[-/]\d{4}\b",  # MM-DD-YYYY or MM/DD/YYYY
        r"\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b",  # Month DD, YYYY
        r"\b\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b",  # DD Month YYYY
        r"\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}\b",  # Month YYYY
    ]

    # Iterate through the patterns to find potential date strings in the query.
    for pattern in date_patterns:
        matches = re.finditer(pattern, query, re.IGNORECASE)
        for match in matches:
            date_text = match.group(0)
            try:
                # Use the powerful `dateutil.parser.parse` to convert the found
                # string into a datetime object. It can handle a wide variety of formats.
                parsed_date = date_parser.parse(date_text, fuzzy=False)
                # Return the first successfully parsed date in a standardized format.
                return parsed_date.strftime("%Y-%m-%d")
            except (ValueError, TypeError):
                # If parsing fails, just continue to the next potential match.
                continue
    # If no patterns match or no matches can be parsed, return an empty string.
    return ""